{"settings":{"languages":["en"],"forceNER":true,"tag":"nlp","threshold":0.5,"autoLoad":true,"autoSave":true,"modelFileName":"model.nlp","executeActionsBeforeAnswers":false,"calculateSentiment":true},"nluManager":{"settings":{"tag":"nlu-manager"},"locales":["en"],"languageNames":{},"domainManagers":{"en":{"settings":{"locale":"en","trainByDomain":false,"tag":"domain-manager-en","nluByDomain":{"default":{"className":"NeuralNlu","settings":{}}},"useStemDict":true},"stemDict":{"big,is,notat,o,what":{"intent":"dsa.answer","domain":"default"},"and,between,complexity,differ,space,time":{"intent":"dsa.answer","domain":"default"},"amort,analysi":{"intent":"dsa.answer","domain":"default"},"binary,case,edg,search":{"intent":"dsa.answer","domain":"default"},"explan,merg,sort":{"intent":"dsa.answer","domain":"default"},"algorithm,quick,sort":{"intent":"dsa.answer","domain":"default"},"explan,heap,sort":{"intent":"dsa.answer","domain":"default"},"count,sort":{"intent":"dsa.answer","domain":"default"},"radix,sort":{"intent":"dsa.answer","domain":"default"},"bucket,sort":{"intent":"dsa.answer","domain":"default"},"and,differ,queue,stack":{"intent":"dsa.answer","domain":"default"},"array,link,list,vs":{"intent":"dsa.answer","domain":"default"},"case,circular,link,list,use":{"intent":"dsa.answer","domain":"default"},"advantag,doubly,link,list":{"intent":"dsa.answer","domain":"default"},"collis,handl,hash,map":{"intent":"dsa.answer","domain":"default"},"to,trie,use,when":{"intent":"dsa.answer","domain":"default"},"applic,heap":{"intent":"dsa.answer","domain":"default"},"and,avl,between,bst,differ,tree":{"intent":"dsa.answer","domain":"default"},"segment,tree,use":{"intent":"dsa.answer","domain":"default"},"binary,fenwick,index,or,tree":{"intent":"dsa.answer","domain":"default"},"bfs,dfs,differ":{"intent":"dsa.answer","domain":"default"},"cycl,detect,direct,graph,in":{"intent":"dsa.answer","domain":"default"},"cycl,detect,graph,in,undirect":{"intent":"dsa.answer","domain":"default"},"algorithm,dijkstra":{"intent":"dsa.answer","domain":"default"},"algorithm,bellman,ford":{"intent":"dsa.answer","domain":"default"},"algorithm,floyd,warshal":{"intent":"dsa.answer","domain":"default"},"sort,topolog":{"intent":"dsa.answer","domain":"default"},"algorithm,kruskal":{"intent":"dsa.answer","domain":"default"},"algorithm,prim":{"intent":"dsa.answer","domain":"default"},"algorithm,tarjan":{"intent":"dsa.answer","domain":"default"},"concept,dynam,program":{"intent":"dsa.answer","domain":"default"},"knapsack,problem,type":{"intent":"dsa.answer","domain":"default"},"common,longest,subsequ":{"intent":"dsa.answer","domain":"default"},"increas,longest,subsequ":{"intent":"dsa.answer","domain":"default"},"distanc,edit,problem":{"intent":"dsa.answer","domain":"default"},"chang,coin,problem":{"intent":"dsa.answer","domain":"default"},"algorithm,kadan":{"intent":"dsa.answer","domain":"default"},"slide,techniqu,window":{"intent":"dsa.answer","domain":"default"},"pointer,techniqu,two":{"intent":"dsa.answer","domain":"default"},"algorithm,kmp":{"intent":"dsa.answer","domain":"default"},"algorithm,karp,rabin":{"intent":"dsa.answer","domain":"default"},"algorithm,manach":{"intent":"dsa.answer","domain":"default"},"algorithm,z":{"intent":"dsa.answer","domain":"default"},"for,hashmap,storag,string,trie,vs":{"intent":"dsa.answer","domain":"default"},"cach,implement,lru":{"intent":"dsa.answer","domain":"default"},"element,frequent,k,top":{"intent":"dsa.answer","domain":"default"},"monoton,stack,usag":{"intent":"dsa.answer","domain":"default"},"compress,find,path,union":{"intent":"dsa.answer","domain":"default"},"and,backtrack,between,differ,recurs":{"intent":"dsa.answer","domain":"default"},"and,backtrack,between,dfs,differ":{"intent":"dsa.answer","domain":"default"},"and,conquer,divid,exampl":{"intent":"dsa.answer","domain":"default"},"algorithm,exampl,greedy":{"intent":"dsa.answer","domain":"default"},"array,prefix,sum,use":{"intent":"dsa.answer","domain":"default"},"and,between,differ,sort,stabl,unstabl":{"intent":"dsa.answer","domain":"default"},"complexity,heap,of,oper,time":{"intent":"dsa.answer","domain":"default"},"and,between,dequ,differ,queue":{"intent":"dsa.answer","domain":"default"},"and,between,bfs,differ,dijkstra":{"intent":"dsa.answer","domain":"default"}},"intentDict":{"dsa.answer":"default"},"sentences":[{"domain":"default","utterance":"what is big o notation","intent":"dsa.answer"},{"domain":"default","utterance":"difference between time and space complexity","intent":"dsa.answer"},{"domain":"default","utterance":"amortized analysis","intent":"dsa.answer"},{"domain":"default","utterance":"binary search edge cases","intent":"dsa.answer"},{"domain":"default","utterance":"merge sort explanation","intent":"dsa.answer"},{"domain":"default","utterance":"quick sort algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"heap sort explanation","intent":"dsa.answer"},{"domain":"default","utterance":"counting sort","intent":"dsa.answer"},{"domain":"default","utterance":"radix sort","intent":"dsa.answer"},{"domain":"default","utterance":"bucket sort","intent":"dsa.answer"},{"domain":"default","utterance":"stack and queue difference","intent":"dsa.answer"},{"domain":"default","utterance":"linked list vs array","intent":"dsa.answer"},{"domain":"default","utterance":"circular linked list use case","intent":"dsa.answer"},{"domain":"default","utterance":"doubly linked list advantage","intent":"dsa.answer"},{"domain":"default","utterance":"hash map collision handling","intent":"dsa.answer"},{"domain":"default","utterance":"when to use trie","intent":"dsa.answer"},{"domain":"default","utterance":"heap applications","intent":"dsa.answer"},{"domain":"default","utterance":"difference between bst and avl tree","intent":"dsa.answer"},{"domain":"default","utterance":"segment tree use","intent":"dsa.answer"},{"domain":"default","utterance":"fenwick tree or binary indexed tree","intent":"dsa.answer"},{"domain":"default","utterance":"difference bfs dfs","intent":"dsa.answer"},{"domain":"default","utterance":"detect cycle in directed graph","intent":"dsa.answer"},{"domain":"default","utterance":"detect cycle in undirected graph","intent":"dsa.answer"},{"domain":"default","utterance":"dijkstra algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"bellman ford algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"floyd warshall algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"topological sort","intent":"dsa.answer"},{"domain":"default","utterance":"kruskal algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"prim algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"tarjan algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"dynamic programming concept","intent":"dsa.answer"},{"domain":"default","utterance":"knapsack problem types","intent":"dsa.answer"},{"domain":"default","utterance":"longest common subsequence","intent":"dsa.answer"},{"domain":"default","utterance":"longest increasing subsequence","intent":"dsa.answer"},{"domain":"default","utterance":"edit distance problem","intent":"dsa.answer"},{"domain":"default","utterance":"coin change problem","intent":"dsa.answer"},{"domain":"default","utterance":"kadane algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"sliding window technique","intent":"dsa.answer"},{"domain":"default","utterance":"two pointer technique","intent":"dsa.answer"},{"domain":"default","utterance":"kmp algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"rabin karp algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"manacher algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"z algorithm","intent":"dsa.answer"},{"domain":"default","utterance":"trie vs hashmap for string storage","intent":"dsa.answer"},{"domain":"default","utterance":"lru cache implementation","intent":"dsa.answer"},{"domain":"default","utterance":"top k frequent elements","intent":"dsa.answer"},{"domain":"default","utterance":"monotonic stack usage","intent":"dsa.answer"},{"domain":"default","utterance":"union find path compression","intent":"dsa.answer"},{"domain":"default","utterance":"difference between recursion and backtracking","intent":"dsa.answer"},{"domain":"default","utterance":"difference between dfs and backtracking","intent":"dsa.answer"},{"domain":"default","utterance":"divide and conquer examples","intent":"dsa.answer"},{"domain":"default","utterance":"greedy algorithm examples","intent":"dsa.answer"},{"domain":"default","utterance":"prefix sum array use","intent":"dsa.answer"},{"domain":"default","utterance":"difference between stable and unstable sort","intent":"dsa.answer"},{"domain":"default","utterance":"time complexity of heap operations","intent":"dsa.answer"},{"domain":"default","utterance":"difference between queue and deque","intent":"dsa.answer"},{"domain":"default","utterance":"difference between bfs and dijkstra","intent":"dsa.answer"}],"domains":{"master_domain":{"settings":{"locale":"en","tag":"nlu-en","keepStopwords":true,"nonefeatureValue":1,"nonedeltaMultiplier":1.2,"spellCheck":false,"spellCheckDistance":1,"filterZeros":true,"log":true},"features":{"what":1,"is":1,"big":1,"o":1,"notat":1,"differ":1,"between":1,"time":1,"and":1,"space":1,"complexity":1,"amort":1,"analysi":1,"binary":1,"search":1,"edg":1,"case":1,"merg":1,"sort":1,"explan":1,"quick":1,"algorithm":1,"heap":1,"count":1,"radix":1,"bucket":1,"stack":1,"queue":1,"link":1,"list":1,"vs":1,"array":1,"circular":1,"use":1,"doubly":1,"advantag":1,"hash":1,"map":1,"collis":1,"handl":1,"when":1,"to":1,"trie":1,"applic":1,"bst":1,"avl":1,"tree":1,"segment":1,"fenwick":1,"or":1,"index":1,"bfs":1,"dfs":1,"detect":1,"cycl":1,"in":1,"direct":1,"graph":1,"undirect":1,"dijkstra":1,"bellman":1,"ford":1,"floyd":1,"warshal":1,"topolog":1,"kruskal":1,"prim":1,"tarjan":1,"dynam":1,"program":1,"concept":1,"knapsack":1,"problem":1,"type":1,"longest":1,"common":1,"subsequ":1,"increas":1,"edit":1,"distanc":1,"coin":1,"chang":1,"kadan":1,"slide":1,"window":1,"techniqu":1,"two":1,"pointer":1,"kmp":1,"rabin":1,"karp":1,"manach":1,"z":1,"hashmap":1,"for":1,"string":1,"storag":1,"lru":1,"cach":1,"implement":1,"top":1,"k":1,"frequent":1,"element":1,"monoton":1,"usag":1,"union":1,"find":1,"path":1,"compress":1,"recurs":1,"backtrack":1,"divid":1,"conquer":1,"exampl":1,"greedy":1,"prefix":1,"sum":1,"stabl":1,"unstabl":1,"of":1,"oper":1,"dequ":1},"intents":{"dsa.answer":1},"intentFeatures":{"dsa.answer":{"what":1,"is":1,"big":1,"o":1,"notat":1,"differ":1,"between":1,"time":1,"and":1,"space":1,"complexity":1,"amort":1,"analysi":1,"binary":1,"search":1,"edg":1,"case":1,"merg":1,"sort":1,"explan":1,"quick":1,"algorithm":1,"heap":1,"count":1,"radix":1,"bucket":1,"stack":1,"queue":1,"link":1,"list":1,"vs":1,"array":1,"circular":1,"use":1,"doubly":1,"advantag":1,"hash":1,"map":1,"collis":1,"handl":1,"when":1,"to":1,"trie":1,"applic":1,"bst":1,"avl":1,"tree":1,"segment":1,"fenwick":1,"or":1,"index":1,"bfs":1,"dfs":1,"detect":1,"cycl":1,"in":1,"direct":1,"graph":1,"undirect":1,"dijkstra":1,"bellman":1,"ford":1,"floyd":1,"warshal":1,"topolog":1,"kruskal":1,"prim":1,"tarjan":1,"dynam":1,"program":1,"concept":1,"knapsack":1,"problem":1,"type":1,"longest":1,"common":1,"subsequ":1,"increas":1,"edit":1,"distanc":1,"coin":1,"chang":1,"kadan":1,"slide":1,"window":1,"techniqu":1,"two":1,"pointer":1,"kmp":1,"rabin":1,"karp":1,"manach":1,"z":1,"hashmap":1,"for":1,"string":1,"storag":1,"lru":1,"cach":1,"implement":1,"top":1,"k":1,"frequent":1,"element":1,"monoton":1,"usag":1,"union":1,"find":1,"path":1,"compress":1,"recurs":1,"backtrack":1,"divid":1,"conquer":1,"exampl":1,"greedy":1,"prefix":1,"sum":1,"stabl":1,"unstabl":1,"of":1,"oper":1,"dequ":1}},"featuresToIntent":{"what":["dsa.answer"],"is":["dsa.answer"],"big":["dsa.answer"],"o":["dsa.answer"],"notat":["dsa.answer"],"differ":["dsa.answer"],"between":["dsa.answer"],"time":["dsa.answer"],"and":["dsa.answer"],"space":["dsa.answer"],"complexity":["dsa.answer"],"amort":["dsa.answer"],"analysi":["dsa.answer"],"binary":["dsa.answer"],"search":["dsa.answer"],"edg":["dsa.answer"],"case":["dsa.answer"],"merg":["dsa.answer"],"sort":["dsa.answer"],"explan":["dsa.answer"],"quick":["dsa.answer"],"algorithm":["dsa.answer"],"heap":["dsa.answer"],"count":["dsa.answer"],"radix":["dsa.answer"],"bucket":["dsa.answer"],"stack":["dsa.answer"],"queue":["dsa.answer"],"link":["dsa.answer"],"list":["dsa.answer"],"vs":["dsa.answer"],"array":["dsa.answer"],"circular":["dsa.answer"],"use":["dsa.answer"],"doubly":["dsa.answer"],"advantag":["dsa.answer"],"hash":["dsa.answer"],"map":["dsa.answer"],"collis":["dsa.answer"],"handl":["dsa.answer"],"when":["dsa.answer"],"to":["dsa.answer"],"trie":["dsa.answer"],"applic":["dsa.answer"],"bst":["dsa.answer"],"avl":["dsa.answer"],"tree":["dsa.answer"],"segment":["dsa.answer"],"fenwick":["dsa.answer"],"or":["dsa.answer"],"index":["dsa.answer"],"bfs":["dsa.answer"],"dfs":["dsa.answer"],"detect":["dsa.answer"],"cycl":["dsa.answer"],"in":["dsa.answer"],"direct":["dsa.answer"],"graph":["dsa.answer"],"undirect":["dsa.answer"],"dijkstra":["dsa.answer"],"bellman":["dsa.answer"],"ford":["dsa.answer"],"floyd":["dsa.answer"],"warshal":["dsa.answer"],"topolog":["dsa.answer"],"kruskal":["dsa.answer"],"prim":["dsa.answer"],"tarjan":["dsa.answer"],"dynam":["dsa.answer"],"program":["dsa.answer"],"concept":["dsa.answer"],"knapsack":["dsa.answer"],"problem":["dsa.answer"],"type":["dsa.answer"],"longest":["dsa.answer"],"common":["dsa.answer"],"subsequ":["dsa.answer"],"increas":["dsa.answer"],"edit":["dsa.answer"],"distanc":["dsa.answer"],"coin":["dsa.answer"],"chang":["dsa.answer"],"kadan":["dsa.answer"],"slide":["dsa.answer"],"window":["dsa.answer"],"techniqu":["dsa.answer"],"two":["dsa.answer"],"pointer":["dsa.answer"],"kmp":["dsa.answer"],"rabin":["dsa.answer"],"karp":["dsa.answer"],"manach":["dsa.answer"],"z":["dsa.answer"],"hashmap":["dsa.answer"],"for":["dsa.answer"],"string":["dsa.answer"],"storag":["dsa.answer"],"lru":["dsa.answer"],"cach":["dsa.answer"],"implement":["dsa.answer"],"top":["dsa.answer"],"k":["dsa.answer"],"frequent":["dsa.answer"],"element":["dsa.answer"],"monoton":["dsa.answer"],"usag":["dsa.answer"],"union":["dsa.answer"],"find":["dsa.answer"],"path":["dsa.answer"],"compress":["dsa.answer"],"recurs":["dsa.answer"],"backtrack":["dsa.answer"],"divid":["dsa.answer"],"conquer":["dsa.answer"],"exampl":["dsa.answer"],"greedy":["dsa.answer"],"prefix":["dsa.answer"],"sum":["dsa.answer"],"stabl":["dsa.answer"],"unstabl":["dsa.answer"],"of":["dsa.answer"],"oper":["dsa.answer"],"dequ":["dsa.answer"]},"neuralNetwork":{"settings":{"locale":"en","tag":"nlu-en","keepStopwords":true,"nonefeatureValue":1,"nonedeltaMultiplier":1.2,"spellCheck":false,"spellCheckDistance":1,"filterZeros":true,"log":true},"features":["what","is","big","o","notat","differ","between","time","and","space","complexity","amort","analysi","binary","search","edg","case","merg","sort","explan","quick","algorithm","heap","count","radix","bucket","stack","queue","link","list","vs","array","circular","use","doubly","advantag","hash","map","collis","handl","when","to","trie","applic","bst","avl","tree","segment","fenwick","or","index","bfs","dfs","detect","cycl","in","direct","graph","undirect","dijkstra","bellman","ford","floyd","warshal","topolog","kruskal","prim","tarjan","dynam","program","concept","knapsack","problem","type","longest","common","subsequ","increas","edit","distanc","coin","chang","kadan","slide","window","techniqu","two","pointer","kmp","rabin","karp","manach","z","hashmap","for","string","storag","lru","cach","implement","top","k","frequent","element","monoton","usag","union","find","path","compress","recurs","backtrack","divid","conquer","exampl","greedy","prefix","sum","stabl","unstabl","of","oper","dequ"],"intents":["dsa.answer"],"perceptrons":[[0.5227906703948975,0.5227906703948975,0.5227906703948975,0.5227906703948975,0.5227906703948975,1.0212198495864868,0.030247611925005913,0.41389307379722595,0.660523533821106,0.11115185171365738,0.41389307379722595,1.3141695261001587,1.3141695261001587,0.9225491881370544,0.6486811637878418,0.6486811637878418,0.393947571516037,0.5803996324539185,1.745814561843872,0.03432523086667061,-1.1842128038406372,2.263720989227295,1.1319383382797241,0.8602747917175293,0.8556452989578247,0.8390337228775024,0.8038401007652283,0.33635640144348145,0.6764897108078003,0.6764897108078003,0.6150532364845276,0.6888512372970581,-0.25453871488571167,1.1358757019042969,0.6367355585098267,0.6367355585098267,0.6606088280677795,0.6606088280677795,0.6606088280677795,0.6606088280677795,0.3971613049507141,0.3971613049507141,0.7162009477615356,1.3933334350585938,0.017525171861052513,0.017525171861052513,0.8918823003768921,0.6006691455841064,0.2744058072566986,0.2744058072566986,0.2744058072566986,0.7035369873046875,0.7878913879394531,0.5837565064430237,0.5837565064430237,0.5837565064430237,0.2993324100971222,0.5837565064430237,0.2854219377040863,0.27223777770996094,0.19172516465187073,0.19172516465187073,0.19638322293758392,0.19638322293758392,0.7759233117103577,0.3972938656806946,0.392348974943161,0.3845084607601166,0.8791170716285706,0.8791170716285706,0.8791170716285706,0.5258747935295105,1.5782241821289062,0.5258747935295105,1.052743673324585,0.5369042754173279,1.052743673324585,0.5176087021827698,0.5273029804229736,0.5273029804229736,0.5277475714683533,0.5277475714683533,0.34856683015823364,0.659160315990448,0.659160315990448,1.3167808055877686,0.659552812576294,0.659552812576294,0.32410380244255066,0.18834874033927917,0.18834874033927917,0.2971523404121399,0.2812846601009369,0.3204849660396576,0.3204849660396576,0.3204849660396576,0.3204849660396576,0.8771599531173706,0.8771599531173706,0.8771599531173706,0.6554250717163086,0.6554250717163086,0.6554250717163086,0.6554250717163086,0.8730524182319641,0.8730524182319641,0.6546096205711365,0.6546096205711365,0.6546096205711365,0.6546096205711365,0.548591673374176,0.276368111371994,0.707345724105835,0.707345724105835,0.5341408252716064,-0.17420658469200134,0.3942144811153412,0.3942144811153412,-0.41988661885261536,-0.41988661885261536,0.3041725158691406,0.3041725158691406,0.4006516933441162,11.679723495285131]]}}}}},"intentDomains":{},"extraSentences":[["en","what is big o notation"],["en","difference between time and space complexity"],["en","amortized analysis"],["en","binary search edge cases"],["en","merge sort explanation"],["en","quick sort algorithm"],["en","heap sort explanation"],["en","counting sort"],["en","radix sort"],["en","bucket sort"],["en","stack and queue difference"],["en","linked list vs array"],["en","circular linked list use case"],["en","doubly linked list advantage"],["en","hash map collision handling"],["en","when to use trie"],["en","heap applications"],["en","difference between bst and avl tree"],["en","segment tree use"],["en","fenwick tree or binary indexed tree"],["en","difference bfs dfs"],["en","detect cycle in directed graph"],["en","detect cycle in undirected graph"],["en","dijkstra algorithm"],["en","bellman ford algorithm"],["en","floyd warshall algorithm"],["en","topological sort"],["en","kruskal algorithm"],["en","prim algorithm"],["en","tarjan algorithm"],["en","dynamic programming concept"],["en","knapsack problem types"],["en","longest common subsequence"],["en","longest increasing subsequence"],["en","edit distance problem"],["en","coin change problem"],["en","kadane algorithm"],["en","sliding window technique"],["en","two pointer technique"],["en","kmp algorithm"],["en","rabin karp algorithm"],["en","manacher algorithm"],["en","z algorithm"],["en","trie vs hashmap for string storage"],["en","lru cache implementation"],["en","top k frequent elements"],["en","monotonic stack usage"],["en","union find path compression"],["en","difference between recursion and backtracking"],["en","difference between dfs and backtracking"],["en","divide and conquer examples"],["en","greedy algorithm examples"],["en","prefix sum array use"],["en","difference between stable and unstable sort"],["en","time complexity of heap operations"],["en","difference between queue and deque"],["en","difference between bfs and dijkstra"]]},"ner":{"settings":{"tag":"ner","entityPreffix":"%","entitySuffix":"%"},"rules":{}},"nlgManager":{"settings":{"tag":"nlg-manager"},"responses":{"en":{"dsa.answer":[{"answer":"Big-O notation expresses the upper bound of time/space complexity as input size grows. Common classes: O(1), O(log n), O(n), O(n log n), O(n^2)."},{"answer":"Time complexity measures running time; space complexity measures memory used. Both depend on input size growth rate."},{"answer":"Amortized analysis averages cost over a sequence of operations. Example: dynamic array resizing — occasional O(n) cost, but O(1) amortized per insert."},{"answer":"Binary search edges: empty array, single element, all same values, target less/greater than all, mid overflow via l + (r-l)//2."},{"answer":"Merge sort divides array into halves, recursively sorts, then merges. Always O(n log n) time, O(n) space, stable."},{"answer":"Quicksort picks pivot, partitions smaller on left larger on right, then recurses. Avg O(n log n), worst O(n^2)."},{"answer":"Heap sort builds a max-heap, then repeatedly extracts the max and rebuilds heap. O(n log n) time, O(1) space, not stable."},{"answer":"Counting sort counts occurrences of elements. Works for small integer ranges. O(n+k) time, O(k) space, stable."},{"answer":"Radix sort sorts digits from LSD to MSD using counting sort. O(nk) time for k-digit numbers, stable."},{"answer":"Bucket sort divides range into buckets, sorts each (often via insertion sort), and merges. Good for uniform data."},{"answer":"Stack: LIFO (last in, first out). Queue: FIFO (first in, first out). Used for recursion vs task scheduling respectively."},{"answer":"Linked list: dynamic size, O(1) insertion/deletion but O(n) access. Array: fixed size, O(1) access but costly insertion/deletion."},{"answer":"Circular linked list connects tail to head, good for round-robin scheduling or buffering."},{"answer":"Doubly linked lists allow O(1) backward traversal and deletion with a reference to the node."},{"answer":"Handled by chaining (linked lists) or open addressing (linear, quadratic, double hashing)."},{"answer":"Trie stores strings by shared prefixes. Used for autocomplete, spell check, and prefix searches."},{"answer":"Heaps are used in priority queues, Dijkstra, median finding, and scheduling tasks."},{"answer":"BST may become skewed; AVL self-balances with rotations, keeping height O(log n)."},{"answer":"Segment Tree answers range queries (sum/min/max) and updates in O(log n)."},{"answer":"BIT efficiently supports prefix sums and updates in O(log n) using binary indexing."},{"answer":"BFS explores level by level using a queue. DFS goes deep using recursion or a stack."},{"answer":"Use DFS with recursion stack or Kahn’s topological sort checking leftover nodes."},{"answer":"Use DFS with parent tracking or Union-Find (Disjoint Set)."},{"answer":"Dijkstra finds shortest paths from source to all nodes with non-negative weights using a priority queue. O((V+E) log V)."},{"answer":"Bellman-Ford finds shortest paths allowing negative weights. O(VE) time, detects negative cycles."},{"answer":"Floyd-Warshall finds all-pairs shortest paths. O(n^3) time, works with negative weights (no cycles)."},{"answer":"Orders DAG nodes so edges go from earlier to later. Done via DFS or Kahn’s algorithm."},{"answer":"Kruskal builds MST by sorting edges and using Union-Find to avoid cycles. O(E log E)."},{"answer":"Prim builds MST by adding smallest edge from current tree to new vertex. O(E log V) with heap."},{"answer":"Tarjan’s algorithm finds strongly connected components using DFS timestamps. O(V+E)."},{"answer":"DP solves overlapping subproblems using optimal substructure, via memoization or tabulation."},{"answer":"0/1 Knapsack uses DP; fractional knapsack uses greedy sorting by value/weight ratio."},{"answer":"LCS between strings A and B found using DP table. O(n*m) time and space."},{"answer":"LIS finds max length of increasing subsequence. O(n log n) using binary search."},{"answer":"Finds min operations (insert, delete, replace) to convert string A to B using DP. O(n*m)."},{"answer":"DP problem finding number of ways or min coins to make amount. O(n*amount)."},{"answer":"Kadane’s algorithm finds maximum subarray sum in O(n) time using running sum tracking."},{"answer":"Used for subarray/substring problems by maintaining a moving window. O(n) typically."},{"answer":"Two pointers move inwards/outwards to optimize search in sorted arrays, used in 2-sum, merge arrays, etc."},{"answer":"KMP pattern matching precomputes lps array to avoid rechecking. O(n+m) time."},{"answer":"Uses rolling hash for string matching. O(n+m) average, O(nm) worst."},{"answer":"Manacher finds longest palindromic substring in O(n) time using mirror expansion."},{"answer":"Z-algorithm computes prefix matches efficiently for pattern search. O(n+m)."},{"answer":"Trie is better for prefix search; hashmap for exact matches."},{"answer":"LRU uses hash map + doubly linked list for O(1) get and put operations."},{"answer":"Use min-heap or bucket sort to track top k frequencies. O(n log k)."},{"answer":"Monotonic stacks track increasing/decreasing elements. Used in next greater element, stock span, histogram problems."},{"answer":"Path compression flattens tree structure for near O(1) find operations."},{"answer":"Recursion divides tasks hierarchically; backtracking undoes invalid choices to explore all valid solutions."},{"answer":"DFS explores depth first, may stop early; backtracking explores all paths by undoing steps when invalid."},{"answer":"Examples: Merge Sort, Quick Sort, Binary Search, Closest Pair of Points."},{"answer":"Greedy examples: Huffman coding, Kruskal, Prim, Fractional Knapsack, Activity selection."},{"answer":"Prefix sum array precomputes cumulative sums to answer range queries in O(1)."},{"answer":"Stable sort preserves order of equal elements. Merge and insertion sort are stable; quicksort and heap sort are not."},{"answer":"Insert O(log n), extract-min/max O(log n), peek O(1), build heap O(n)."},{"answer":"Queue allows insert at rear and delete at front; deque allows both ends."},{"answer":"BFS gives shortest path in unweighted graphs; Dijkstra does for weighted graphs with non-negative edges."}]}}},"actionManager":{"settings":{"tag":"action-manager"},"actions":{}},"slotManager":{}}